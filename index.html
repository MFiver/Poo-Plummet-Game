<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Poo Plummet</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
    body { margin: 0; padding: 0; box-sizing: border-box; }
    .game-container { display: block; margin: 0 auto; text-align: center; width: 400px; }
    #gameCanvas { display: block; margin: 0 auto; touch-action: none; }
  </style>
</head>
<body class="bg-gray-100">
  <div class="game-container">
    <div class="bg-amber-900 text-white text-2xl sm:text-3xl md:text-4xl font-bold py-2">POO PLUMMET</div>
    <p id="level" class="my-1 text-sm sm:text-base">Level: 1</p>
    <p id="highScore" class="my-1 text-sm sm:text-base">High Score: None</p>
    <div id="gameCanvas" class="mt-2" onselectstart="return false;"></div>
    <p id="feedback" class="mt-2 text-base sm:text-lg"></p>
    <button id="restartButton" onclick="restartGame()" class="mt-2 bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 hidden">Play Again</button>
  </div>

  <script>
    let pooX, pooY, pooSpeed, windForce;
    let toiletX, toiletWidth, toiletSpeed, toiletBaseX;
    let gameOver = false;
    let level = 1;
    let highScore = { name: "None", score: 0 };
    let showHighScoreAnimation = false;
    let showFailureAnimation = false;
    let animationTimer = 0;
    let particles = [];
    let userInteracted = false;
    let moveDirection = null; // "left", "right", or null
    let fartPlayed = false; // Track if fart sound has played for current level
    const fartSound = new Audio('https://cdn.pixabay.com/audio/2023/03/29/12-24-24-614_1.mp3');
    const splashSound = new Audio('https://cdn.pixabay.com/audio/2022/08/02/14-21-45-597_1.mp3');
    const backgroundMusic = new Audio('https://cdn.pixabay.com/audio/2022/03/28/01-40-28-915_1.mp3');
    const colors = [
      [255, 0, 0], // Red
      [0, 0, 255], // Blue
      [0, 255, 0], // Green
      [255, 255, 0] // Yellow
    ];
    let colorIndex = 0;

    function preload() {
      try {
        fartSound.load();
        fartSound.volume = 0.5;
        splashSound.load();
        splashSound.volume = 0.5;
        backgroundMusic.load();
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.3;
        console.log('Audio files preloaded');
      } catch (e) {
        console.error('Audio preload failed:', e);
      }
    }

    function setup() {
      try {
        let canvas = createCanvas(400, 500);
        canvas.parent('gameCanvas');
        loadHighScore();
        resetLevel();
        canvas.elt.addEventListener('touchstart', handleTouchStart, false);
        canvas.elt.addEventListener('touchmove', handleTouchMove, false);
        canvas.elt.addEventListener('touchend', handleTouchEnd, false);
        document.addEventListener('keydown', () => {
          userInteracted = true;
          playBackgroundMusic();
          console.log('User interacted via keydown: audio enabled');
        });
        document.addEventListener('click', () => {
          userInteracted = true;
          playBackgroundMusic();
          console.log('User interacted via click: audio enabled');
        });
        console.log('Game setup completed');
      } catch (e) {
        console.error('Setup failed:', e);
      }
    }

    function handleTouchStart(event) {
      userInteracted = true;
      playBackgroundMusic();
      if (event.touches.length > 0) {
        let touchX = event.touches[0].clientX - canvas.elt.getBoundingClientRect().left;
        moveDirection = touchX < 200 ? 'left' : 'right';
        console.log('Touch started:', moveDirection, 'at x:', touchX, 'pooX:', pooX);
      }
      event.preventDefault();
      return false;
    }

    function handleTouchMove(event) {
      if (event.touches.length > 0) {
        let touchX = event.touches[0].clientX - canvas.elt.getBoundingClientRect().left;
        moveDirection = touchX < 200 ? 'left' : 'right';
        console.log('Touch moved:', moveDirection, 'at x:', touchX, 'pooX:', pooX);
      }
      event.preventDefault();
      return false;
    }

    function handleTouchEnd(event) {
      moveDirection = null;
      console.log('Touch ended, pooX:', pooX);
      event.preventDefault();
      return false;
    }

    function playBackgroundMusic() {
      if (userInteracted && !gameOver && backgroundMusic.paused) {
        backgroundMusic.play().catch(e => console.error('Background music failed:', e));
      }
    }

    function loadHighScore() {
      try {
        const saved = localStorage.getItem('pooPlummetHighScore');
        if (saved) {
          highScore = JSON.parse(saved);
          console.log('Loaded high score:', highScore);
        } else {
          console.log('No high score found in localStorage');
        }
        updateHighScoreDisplay();
      } catch (e) {
        console.error('Load high score failed:', e);
      }
    }

    function saveHighScore() {
      try {
        localStorage.setItem('pooPlummetHighScore', JSON.stringify(highScore));
        console.log('Saved high score:', highScore);
        updateHighScoreDisplay();
      } catch (e) {
        console.error('Save high score failed:', e);
      }
    }

    function updateHighScoreDisplay() {
      document.getElementById('highScore').textContent = `High Score: ${highScore.name} - Level ${highScore.score}`;
    }

    function resetLevel() {
      pooX = width / 2;
      pooY = 50;
      pooSpeed = 2;
      windForce = 0;
      toiletBaseX = random(50, width - 50);
      toiletX = toiletBaseX;
      toiletWidth = 45;
      toiletSpeed = level >= 10 ? 0.02 + (Math.min(level, 15) - 10) * 0.01 : 0;
      gameOver = false;
      showHighScoreAnimation = false;
      showFailureAnimation = false;
      animationTimer = 0;
      particles = [];
      fartPlayed = false;
      document.getElementById('feedback').textContent = '';
      document.getElementById('restartButton').classList.add('hidden');
      document.getElementById('level').textContent = `Level: ${level}`;
      console.log('Level reset:', level, 'Toilet speed:', toiletSpeed);
    }

    function restartGame() {
      level = 1;
      resetLevel();
      playBackgroundMusic();
      console.log('Game restarted');
    }

    function draw() {
      try {
        if (level >= 20) {
          if (frameCount % 10 === 0) {
            colorIndex = (colorIndex + 1) % colors.length;
          }
          background(colors[colorIndex]);
        } else {
          background(0);
        }
        noStroke();

        if (!gameOver) {
          let windRange = level >= 10 ? 1.5 + (Math.min(level, 15) - 10) * 0.75 : 1.5 + (level - 1) * 0.75;
          windForce = random(-windRange, windRange);
          if (level >= 10) {
            toiletX = toiletBaseX + sin(frameCount * toiletSpeed) * 50;
            toiletX = constrain(toiletX, 50, width - 50);
          }
          pooX += windForce;
          if (keyIsDown(LEFT_ARROW)) pooX -= 2;
          if (keyIsDown(RIGHT_ARROW)) pooX += 2;
          if (moveDirection === 'left') pooX -= 2; // Move left for left side press
          if (moveDirection === 'right') pooX += 2; // Move right for right side press
          pooY += pooSpeed;
          pooX = constrain(pooX, 0, width);

          if (!fartPlayed && pooY < 60 && userInteracted) {
            fartSound.play().catch(e => console.error('Fart sound failed:', e));
            fartPlayed = true;
          }

          if (pooY >= height - 45) {
            gameOver = true;
            backgroundMusic.pause();
            let feedback = document.getElementById('feedback');
            if (pooX >= toiletX - toiletWidth / 2 && pooX <= toiletX + toiletWidth / 2) {
              feedback.textContent = `Success! On to Level ${level + 1}!`;
              feedback.classList.add('text-green-600');
              if (userInteracted) {
                splashSound.play().catch(e => console.error('Splash sound failed:', e));
              }
              level++;
              resetLevel();
              playBackgroundMusic();
            } else {
              feedback.textContent = `Missed! Game Over at Level ${level}.`;
              feedback.classList.add('text-red-600');
              showFailureAnimation = true;
              createParticles();
              console.log('Checking high score: current level', level, 'vs high score', highScore.score);
              if (level - 1 > highScore.score) {
                let name = window.prompt('New High Score! Enter your name:', 'Player');
                console.log('Prompt result:', name);
                if (name !== null) {
                  highScore = { name: name.trim() || 'Anonymous', score: level - 1 };
                  saveHighScore();
                  showHighScoreAnimation = true;
                  createParticles();
                }
              }
              document.getElementById('restartButton').classList.remove('hidden');
            }
          }
        }

        if (showHighScoreAnimation) {
          animationTimer++;
          let scale = 1 + 0.5 * sin(animationTimer * 0.1);
          textAlign(CENTER);
          textSize(36 * scale);
          textStyle(BOLD);
          fill(random(255), random(255), random(255));
          text("NICE TURD!", width / 2, height / 2 - 20);
          text("NEW HIGH SCORE!", width / 2, height / 2 + 20);
          for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.y += p.speed;
            fill(p.r, p.g, p.b, p.alpha);
            ellipse(p.x, p.y, 5, 5);
            p.alpha -= 5;
            if (p.alpha <= 0) particles.splice(i, 1);
          }
          if (animationTimer > 120) showHighScoreAnimation = false;
        }

        if (showFailureAnimation) {
          animationTimer++;
          let scale = 1 + 0.5 * sin(animationTimer * 0.1);
          textAlign(CENTER);
          textSize(36 * scale);
          textStyle(BOLD);
          fill(random(255), random(255), random(255));
          text("YOU MISSED!", width / 2, height / 2 - 20);
          text("TRY AGAIN!", width / 2, height / 2 + 20);
          for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.y += p.speed;
            fill(p.r, p.g, p.b, p.alpha);
            ellipse(p.x, p.y, 5, 5);
            p.alpha -= 5;
            if (p.alpha <= 0) particles.splice(i, 1);
          }
          if (animationTimer > 120) showFailureAnimation = false;
        }

        let tileSize = 10;
        for (let x = 0; x < width; x += tileSize) {
          for (let y = height - 20; y < height; y += tileSize) {
            fill((x / tileSize + y / tileSize) % 2 === 0 ? 255 : 0);
            rect(x, y, tileSize, tileSize);
          }
        }

        fill(255);
        rect(toiletX - 30, height - 120, 60, 60);
        arc(toiletX, height - 60, 60, 45, PI, 0);
        arc(toiletX, height - 60, 60, 45, 0, PI);
        stroke(200);
        strokeWeight(3);
        noFill();
        arc(toiletX, height - 60, 66, 51, PI, 0);
        noStroke();
        fill(0, 191, 255);
        ellipse(toiletX, height - 60, 45, 22.5);

        fill(139, 69, 19);
        beginShape();
        vertex(pooX - 7.5, pooY - 15);
        vertex(pooX + 7.5, pooY - 12);
        vertex(pooX + 10.5, pooY);
        vertex(pooX + 7.5, pooY + 12);
        vertex(pooX - 7.5, pooY + 15);
        vertex(pooX - 10.5, pooY + 3);
        endShape(CLOSE);

        fill(255, 218, 185);
        arc(width / 2 - 40, 0, 80, 80, 0, PI);
        arc(width / 2 + 40, 0, 80, 80, 0, PI);
        noStroke();

        fill(255);
        textAlign(CENTER);
        textSize(14);
        text(`Fart Wind: ${windForce.toFixed(2)}`, width / 2, 80);
      } catch (e) {
        console.error('Draw failed:', e);
      }
    }

    function createParticles() {
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: random(width),
          y: random(height),
          speed: random(1, 3),
          r: random(255),
          g: random(255),
          b: random(255),
          alpha: 255
        });
      }
    }
  </script>
</body>
</html>
